"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const url_1 = require("url");
const AuthSession_1 = tslib_1.__importDefault(require("./AuthSession"));
const enums_1 = require("../../resources/enums");
const Endpoints_1 = tslib_1.__importDefault(require("../../resources/Endpoints"));
class EOSAuthSession extends AuthSession_1.default {
    constructor(client, data, clientSecret) {
        super(client, data, clientSecret, enums_1.AuthSessionType.EOS);
        this.applicationId = data.application_id;
        this.mergedAccounts = data.merged_accounts;
        this.scope = data.scope;
        this.refreshToken = data.refresh_token;
        this.refreshTokenExpiresAt = new Date(data.refresh_expires_at);
    }
    async checkIsValid(forceVerify = false) {
        if (!forceVerify && this.isExpired) {
            return false;
        }
        const validation = await this.client.http.epicgamesRequest({
            method: 'POST',
            url: Endpoints_1.default.EOS_TOKEN_INFO,
            headers: {
                Authorization: `bearer ${this.accessToken}`,
            },
        });
        return validation.active === true;
    }
    async revoke() {
        clearTimeout(this.refreshTimeout);
        this.refreshTimeout = undefined;
        await this.client.http.epicgamesRequest({
            method: 'POST',
            url: Endpoints_1.default.EOS_TOKEN_REVOKE,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            data: new url_1.URLSearchParams({
                token: this.accessToken,
            }).toString(),
        });
    }
    async refresh() {
        clearTimeout(this.refreshTimeout);
        this.refreshTimeout = undefined;
        const refreshedSession = await EOSAuthSession.create(this.client, this.clientId, this.clientSecret, {
            grant_type: 'refresh_token',
            refresh_token: this.refreshToken,
        });
        this.accessToken = refreshedSession.accessToken;
        this.expiresAt = refreshedSession.expiresAt;
        this.refreshToken = refreshedSession.refreshToken;
        this.refreshTokenExpiresAt = refreshedSession.refreshTokenExpiresAt;
        this.applicationId = refreshedSession.applicationId;
        this.mergedAccounts = refreshedSession.mergedAccounts;
        this.scope = refreshedSession.scope;
        this.initRefreshTimeout();
    }
    initRefreshTimeout() {
        clearTimeout(this.refreshTimeout);
        this.refreshTimeout = setTimeout(() => this.refresh(), this.expiresAt.getTime() - Date.now() - 15 * 60 * 1000);
    }
    static async create(client, clientId, clientSecret, data) {
        const response = await client.http.epicgamesRequest({
            method: 'POST',
            url: Endpoints_1.default.EOS_TOKEN,
            headers: {
                Authorization: `Basic ${Buffer.from(`${clientId}:${clientSecret}`).toString('base64')}`,
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            data: new url_1.URLSearchParams(data).toString(),
        });
        const session = new EOSAuthSession(client, response, clientSecret);
        session.initRefreshTimeout();
        return session;
    }
}
exports.default = EOSAuthSession;
//# sourceMappingURL=EOSAuthSession.js.map
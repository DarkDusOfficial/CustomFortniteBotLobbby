"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const collection_1 = require("@discordjs/collection");
const Friend_1 = tslib_1.__importDefault(require("../structures/friend/Friend"));
const FriendNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/FriendNotFoundError"));
const Endpoints_1 = tslib_1.__importDefault(require("../../resources/Endpoints"));
const UserNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/UserNotFoundError"));
const DuplicateFriendshipError_1 = tslib_1.__importDefault(require("../exceptions/DuplicateFriendshipError"));
const FriendshipRequestAlreadySentError_1 = tslib_1.__importDefault(require("../exceptions/FriendshipRequestAlreadySentError"));
const InviteeFriendshipsLimitExceededError_1 = tslib_1.__importDefault(require("../exceptions/InviteeFriendshipsLimitExceededError"));
const InviteeFriendshipRequestLimitExceededError_1 = tslib_1.__importDefault(require("../exceptions/InviteeFriendshipRequestLimitExceededError"));
const InviteeFriendshipSettingsError_1 = tslib_1.__importDefault(require("../exceptions/InviteeFriendshipSettingsError"));
const OfferNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/OfferNotFoundError"));
const SentFriendMessage_1 = tslib_1.__importDefault(require("../structures/friend/SentFriendMessage"));
const BasePendingFriend_1 = tslib_1.__importDefault(require("../structures/friend/BasePendingFriend"));
const Base_1 = tslib_1.__importDefault(require("../Base"));
const enums_1 = require("../../resources/enums");
const EpicgamesAPIError_1 = tslib_1.__importDefault(require("../exceptions/EpicgamesAPIError"));
class FriendManager extends Base_1.default {
    constructor(constr) {
        super(constr);
        this.list = new collection_1.Collection();
        this.pendingList = new collection_1.Collection();
    }
    resolve(friend) {
        if (friend instanceof Friend_1.default) {
            return this.list.get(friend.id);
        }
        if (friend.length === 32) {
            return this.list.get(friend);
        }
        return this.list.find((f) => f.displayName === friend);
    }
    resolvePending(pendingFriend) {
        if (pendingFriend instanceof BasePendingFriend_1.default) {
            return this.pendingList.get(pendingFriend.id);
        }
        if (pendingFriend.length === 32) {
            return this.pendingList.get(pendingFriend);
        }
        return this.pendingList.find((f) => f.displayName === pendingFriend);
    }
    /**
     * Sends a friendship request to a user or accepts an existing request
     * @param friend The id or display name of the user to add
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {DuplicateFriendshipError} The user is already friends with the client
     * @throws {FriendshipRequestAlreadySentError} A friendship request has already been sent to the user
     * @throws {InviterFriendshipsLimitExceededError} The client's friendship limit is reached
     * @throws {InviteeFriendshipsLimitExceededError} The user's friendship limit is reached
     * @throws {InviteeFriendshipSettingsError} The user disabled friend requests
     * @throws {InviteeFriendshipRequestLimitExceededError} The user's incoming friend request limit is reached
     * @throws {EpicgamesAPIError}
     */
    async add(friend) {
        const userID = await this.client.user.resolveId(friend);
        if (!userID)
            throw new UserNotFoundError_1.default(friend);
        try {
            await this.client.http.epicgamesRequest({
                method: 'POST',
                url: `${Endpoints_1.default.FRIEND_ADD}/${this.client.user.self.id}/${userID}`,
            }, enums_1.AuthSessionStoreKey.Fortnite);
        }
        catch (e) {
            if (e instanceof EpicgamesAPIError_1.default) {
                switch (e.code) {
                    case 'errors.com.epicgames.friends.duplicate_friendship':
                        throw new DuplicateFriendshipError_1.default(friend);
                    case 'errors.com.epicgames.friends.friend_request_already_sent':
                        throw new FriendshipRequestAlreadySentError_1.default(friend);
                    case 'errors.com.epicgames.friends.inviter_friendships_limit_exceeded':
                        throw new InviteeFriendshipsLimitExceededError_1.default(friend);
                    case 'errors.com.epicgames.friends.invitee_friendships_limit_exceeded':
                        throw new InviteeFriendshipsLimitExceededError_1.default(friend);
                    case 'errors.com.epicgames.friends.incoming_friendships_limit_exceeded':
                        throw new InviteeFriendshipRequestLimitExceededError_1.default(friend);
                    case 'errors.com.epicgames.friends.cannot_friend_due_to_target_settings':
                        throw new InviteeFriendshipSettingsError_1.default(friend);
                    case 'errors.com.epicgames.friends.account_not_found':
                        throw new UserNotFoundError_1.default(friend);
                }
            }
            throw e;
        }
    }
    /**
     * Removes a friend from the client's friend list or declines / aborts a pending friendship request
     * @param friend The id or display name of the friend
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    async remove(friend) {
        var _a;
        const resolvedFriend = (_a = this.resolve(friend)) !== null && _a !== void 0 ? _a : this.resolvePending(friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        await this.client.http.epicgamesRequest({
            method: 'DELETE',
            url: `${Endpoints_1.default.FRIEND_DELETE}/${this.client.user.self.id}/friends/${resolvedFriend.id}`,
        }, enums_1.AuthSessionStoreKey.Fortnite);
    }
    /**
     * Fetches the friends the client shares with a friend
     * @param friend The id or display name of the friend
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    async getMutual(friend) {
        const resolvedFriend = this.resolve(friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        const mutualFriends = await this.client.http.epicgamesRequest({
            method: 'GET',
            url: `${Endpoints_1.default.FRIENDS}/${this.client.user.self.id}/friends/${resolvedFriend.id}/mutual`,
        }, enums_1.AuthSessionStoreKey.Fortnite);
        return mutualFriends
            .map((f) => this.list.get(f))
            .filter((f) => !!f);
    }
    /**
     * Checks whether a friend owns a specific offer
     * @param friend The id or display name of the friend
     * @param offerId The offer id
     * @throws {OfferNotFoundError} The offer does not exist or is not in the current storefront catalog
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    async checkOfferOwnership(friend, offerId) {
        const resolvedFriend = this.resolve(friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        try {
            await this.client.http.epicgamesRequest({
                method: 'GET',
                url: `${Endpoints_1.default.BR_GIFT_ELIGIBILITY}/recipient/${resolvedFriend.id}/offer/${encodeURIComponent(offerId)}`,
            }, enums_1.AuthSessionStoreKey.Fortnite);
            return false;
        }
        catch (e) {
            if (e instanceof EpicgamesAPIError_1.default) {
                if (e.code === 'errors.com.epicgames.modules.gamesubcatalog.catalog_out_of_date') {
                    throw new OfferNotFoundError_1.default(offerId);
                }
                if (e.code === 'errors.com.epicgames.modules.gamesubcatalog.purchase_not_allowed') {
                    return true;
                }
            }
            throw e;
        }
    }
    /**
     * Sends a message to a friend
     * @param friend The id or display name of the friend
     * @param content The message that will be sent
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {SendMessageError} The messant could not be sent
     */
    async sendMessage(friend, content) {
        const resolvedFriend = this.resolve(friend);
        if (!resolvedFriend) {
            throw new FriendNotFoundError_1.default(friend);
        }
        const messageId = await this.client.chat.whisperUser(resolvedFriend.id, { body: content });
        return new SentFriendMessage_1.default(this.client, {
            author: this.client.user.self,
            content,
            id: messageId,
            sentAt: new Date(),
        });
    }
}
exports.default = FriendManager;
//# sourceMappingURL=FriendManager.js.map
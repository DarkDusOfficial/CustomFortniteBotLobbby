"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const collection_1 = require("@discordjs/collection");
const Base_1 = tslib_1.__importDefault(require("../Base"));
const UserNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/UserNotFoundError"));
const Util_1 = require("../util/Util");
const Endpoints_1 = tslib_1.__importDefault(require("../../resources/Endpoints"));
const EpicgamesAPIError_1 = tslib_1.__importDefault(require("../exceptions/EpicgamesAPIError"));
const enums_1 = require("../../resources/enums");
const UserSearchResult_1 = tslib_1.__importDefault(require("../structures/user/UserSearchResult"));
const AuthenticationMissingError_1 = tslib_1.__importDefault(require("../exceptions/AuthenticationMissingError"));
const User_1 = tslib_1.__importDefault(require("../structures/user/User"));
const Avatar_1 = tslib_1.__importDefault(require("../structures/Avatar"));
const GlobalProfile_1 = tslib_1.__importDefault(require("../structures/GlobalProfile"));
const ClientUser_1 = tslib_1.__importDefault(require("../structures/user/ClientUser"));
class UserManager extends Base_1.default {
    constructor(client) {
        super(client);
        this.blocklist = new collection_1.Collection();
        this.cache = new collection_1.Collection();
        this.self = undefined;
    }
    /**
     * Resolves a user's ID from the cache or via the API
     * @param idOrDisplayName The user's ID or display name
     */
    async resolveId(idOrDisplayName) {
        if (idOrDisplayName.length === 32) {
            return idOrDisplayName;
        }
        const cachedUser = this.cache.find((u) => u.displayName === idOrDisplayName);
        if (cachedUser) {
            return cachedUser.id;
        }
        const user = await this.fetch(idOrDisplayName);
        return user.id;
    }
    async fetch(idOrDisplayName) {
        const [user] = await this.fetchMultiple([idOrDisplayName]);
        if (!user) {
            throw new UserNotFoundError_1.default(idOrDisplayName);
        }
        return user;
    }
    async fetchMultiple(idsOrDisplayNames) {
        var _a, _b;
        const ids = [];
        const displayNames = [];
        const users = [];
        for (const idOrDisplayName of idsOrDisplayNames) {
            if (idOrDisplayName.length === 32) {
                const cachedUser = this.cache.get(idOrDisplayName);
                if (cachedUser) {
                    const cachedUserClone = new User_1.default(this.client, cachedUser.toObject());
                    users.push(cachedUserClone);
                }
                else {
                    ids.push(idOrDisplayName);
                }
            }
            else if (idOrDisplayName.length > 3 && idOrDisplayName.length < 16) {
                const cachedUser = this.cache.find((u) => u.displayName === idOrDisplayName);
                if (cachedUser) {
                    const cachedUserClone = new User_1.default(this.client, cachedUser.toObject());
                    users.push(cachedUserClone);
                }
                else {
                    displayNames.push(idOrDisplayName);
                }
            }
        }
        const idChunks = (0, Util_1.chunk)(ids, 100);
        const fetchedUserData = await Promise.all([
            ...idChunks.map((c) => this.client.http.epicgamesRequest({
                method: 'GET',
                url: `${Endpoints_1.default.ACCOUNT_MULTIPLE}?accountId=${c.join('&accountId=')}`,
            }, enums_1.AuthSessionStoreKey.Fortnite)),
            ...displayNames.map((d) => this.client.http.epicgamesRequest({
                method: 'GET',
                url: `${Endpoints_1.default.ACCOUNT_DISPLAYNAME}/${d}`,
            }, enums_1.AuthSessionStoreKey.Fortnite).catch((e) => {
                if (e instanceof EpicgamesAPIError_1.default && e.code === 'errors.com.epicgames.account.account_not_found') {
                    return undefined;
                }
                return Promise.reject(e);
            })),
        ]);
        const fetchedUsers = fetchedUserData.flat(1).filter((u) => !!u).map((u) => new User_1.default(this.client, u));
        if (((_b = (_a = this.client.config.cacheSettings.users) === null || _a === void 0 ? void 0 : _a.maxLifetime) !== null && _b !== void 0 ? _b : 0) > 0) {
            for (const user of fetchedUsers) {
                const userClone = new User_1.default(this.client, user.toObject());
                userClone.cachedAt = Date.now();
                this.cache.set(user.id, userClone);
            }
        }
        return [...users, ...fetchedUsers];
    }
    async fetchSelf() {
        if (!this.client.auth.sessions.has(enums_1.AuthSessionStoreKey.Fortnite)) {
            throw new AuthenticationMissingError_1.default(enums_1.AuthSessionStoreKey.Fortnite);
        }
        const self = await this.client.http.epicgamesRequest({
            method: 'GET',
            url: `${Endpoints_1.default.ACCOUNT_ID}/${this.client.auth.sessions.get(enums_1.AuthSessionStoreKey.Fortnite).accountId}`,
        }, enums_1.AuthSessionStoreKey.Fortnite);
        this.self = new ClientUser_1.default(this.client, self);
    }
    async search(prefix, platform = 'epic') {
        const results = await this.client.http.epicgamesRequest({
            method: 'GET',
            url: `${Endpoints_1.default.ACCOUNT_SEARCH}/${this.self.id}?prefix=${encodeURIComponent(prefix)}&platform=${platform}`,
        }, enums_1.AuthSessionStoreKey.Fortnite);
        const users = await this.fetchMultiple(results.map((r) => r.accountId));
        return results
            .filter((r) => users.some((u) => u.id === r.accountId))
            .map((r) => new UserSearchResult_1.default(this.client, users.find((u) => u.id === r.accountId), r));
    }
    /**
     * Fetches the avatar of a user
     * @param user The id or display name of the user
     * @throws {EpicgamesAPIError}
     * @throws {UserNotFoundError} The user wasn't found
     */
    async fetchAvatar(idOrDisplayName) {
        const [avatar] = await this.fetchAvatarMultiple([idOrDisplayName]);
        if (!avatar) {
            throw new UserNotFoundError_1.default(idOrDisplayName);
        }
        return avatar;
    }
    /**
     * Fetches the avatar of multiple users
     * @param user The ids and/or display names of the users
     * @throws {EpicgamesAPIError}
     */
    async fetchAvatarMultiple(idsOrDisplayNames) {
        const users = await this.fetchMultiple(idsOrDisplayNames);
        const userChunks = (0, Util_1.chunk)(users, 100);
        const avatars = await Promise.all(userChunks.map((uc) => this.client.http.epicgamesRequest({
            method: 'GET',
            url: `${Endpoints_1.default.ACCOUNT_AVATAR}/fortnite/ids?accountIds=${uc.map((u) => u.id).join(',')}`,
        }, enums_1.AuthSessionStoreKey.Fortnite)));
        return avatars
            .map((a) => a.map((ar) => new Avatar_1.default(this.client, ar, users.find((u) => u.id === ar.accountId))))
            .flat(1);
    }
    /**
     * Fetches the global profile of a user
     * @param user The id or display name of the user
     * @throws {EpicgamesAPIError}
     * @throws {UserNotFoundError} The user wasn't found
     */
    async fetchGlobalProfile(idOrDisplayName) {
        const [profile] = await this.fetchGlobalProfileMultiple([idOrDisplayName]);
        if (!profile) {
            throw new UserNotFoundError_1.default(idOrDisplayName);
        }
        return profile;
    }
    /**
     * Fetches the global profile for multiple users
     * @param user The ids and/or display names of the users
     * @throws {EpicgamesAPIError}
     */
    async fetchGlobalProfileMultiple(idsOrDisplayNames) {
        const users = await this.fetchMultiple(idsOrDisplayNames);
        const userChunks = (0, Util_1.chunk)(users, 100);
        const globalProfiles = await Promise.all(userChunks.map((uc) => this.client.http.epicgamesRequest({
            method: 'PUT',
            url: Endpoints_1.default.ACCOUNT_GLOBAL_PROFILE,
            headers: {
                'Content-Type': 'application/json',
            },
            data: {
                namespace: 'Fortnite',
                accountIds: uc.map((u) => u.id),
            },
        }, enums_1.AuthSessionStoreKey.Fortnite)));
        return globalProfiles
            .map((a) => a.profiles.map((ar) => new GlobalProfile_1.default(this.client, ar, users.find((u) => u.id === ar.accountId))))
            .flat(1);
    }
    /**
     * Blocks a user
     * @param user The id or display name of the user
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    async block(user) {
        const userId = await this.resolveId(user);
        if (!userId)
            throw new UserNotFoundError_1.default(user);
        await this.client.http.epicgamesRequest({
            method: 'POST',
            url: `${Endpoints_1.default.FRIEND_BLOCK}/${this.self.id}/${userId}`,
        }, enums_1.AuthSessionStoreKey.Fortnite);
    }
    /**
     * Unblocks a user
     * @param user The id or display name of the user
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    async unblock(user) {
        const blockedUser = this.blocklist.find((u) => u.displayName === user || u.id === user);
        if (!blockedUser)
            throw new UserNotFoundError_1.default(user);
        await this.client.http.epicgamesRequest({
            method: 'DELETE',
            url: `${Endpoints_1.default.FRIEND_BLOCK}/${this.self.id}/${blockedUser.id}`,
        }, enums_1.AuthSessionStoreKey.Fortnite);
    }
}
exports.default = UserManager;
//# sourceMappingURL=UserManager.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const stompjs_1 = require("@stomp/stompjs");
const ws_1 = tslib_1.__importDefault(require("ws"));
const Base_1 = tslib_1.__importDefault(require("../Base"));
const enums_1 = require("../../resources/enums");
const AuthenticationMissingError_1 = tslib_1.__importDefault(require("../exceptions/AuthenticationMissingError"));
const StompConnectionError_1 = tslib_1.__importDefault(require("../exceptions/StompConnectionError"));
const Endpoints_1 = tslib_1.__importDefault(require("../../resources/Endpoints"));
const ReceivedFriendMessage_1 = tslib_1.__importDefault(require("../structures/friend/ReceivedFriendMessage"));
const PartyMessage_1 = tslib_1.__importDefault(require("../structures/party/PartyMessage"));
/**
 * Represents the client's EOS Connect STOMP manager (i.e. chat messages)
 */
class EOSConnect extends Base_1.default {
    /**
     * @param client The main client
     */
    constructor(client) {
        super(client);
        this.stompConnection = undefined;
        this.stompConnectionId = undefined;
    }
    /**
     * Whether the internal websocket is connected
     */
    get isConnected() {
        return !!this.stompConnection && this.stompConnection.connected;
    }
    /**
     * Returns the eos stomp connection id
     */
    get connectionId() {
        return this.stompConnectionId;
    }
    /**
     * connect to the eos connect stomp server
     * @throws {AuthenticationMissingError} When there is no eos auth to use for stomp auth
     * @throws {StompConnectionError} When the connection failed for any reason
     * @throws {Error} When there was an error with the underlying websocket
     */
    async connect() {
        if (!this.client.auth.sessions.has(enums_1.AuthSessionStoreKey.FortniteEOS)) {
            throw new AuthenticationMissingError_1.default(enums_1.AuthSessionStoreKey.FortniteEOS);
        }
        return new Promise((resolve, reject) => {
            const brokerURL = `wss://${Endpoints_1.default.EOS_STOMP}`;
            this.stompConnection = new stompjs_1.Client({
                brokerURL,
                stompVersions: new stompjs_1.Versions([stompjs_1.Versions.V1_0, stompjs_1.Versions.V1_1, stompjs_1.Versions.V1_2]),
                heartbeatOutgoing: 30000,
                heartbeatIncoming: 0,
                webSocketFactory: () => new ws_1.default(brokerURL, {
                    headers: {
                        Authorization: `Bearer ${this.client.auth.sessions.get(enums_1.AuthSessionStoreKey.FortniteEOS).accessToken}`,
                        'Sec-Websocket-Protocol': 'v10.stomp,v11.stomp,v12.stomp',
                        'Epic-Connect-Protocol': 'stomp',
                        'Epic-Connect-Device-Id': '',
                    },
                }),
                debug: (str) => {
                    var _a, _b;
                    (_b = (_a = this.client.config).stompEosConnectDebug) === null || _b === void 0 ? void 0 : _b.call(_a, str);
                },
                onConnect: () => {
                    this.setupSubscription(resolve, reject);
                },
                onStompError: (frame) => {
                    reject(new StompConnectionError_1.default(frame.body, -1));
                },
                onWebSocketError: (event) => {
                    const errorEvent = event;
                    if (errorEvent.error || errorEvent.message) {
                        let error = undefined;
                        if (errorEvent.error instanceof Error) {
                            error = errorEvent.error;
                        }
                        else {
                            error = new Error(errorEvent.message);
                        }
                        error.message += ' (eos connect stomp)';
                        reject(error);
                    }
                },
            });
            this.client.debug('[STOMP EOS Connect] Connecting...');
            this.stompConnection.activate();
        });
    }
    /**
     * Disconnects the stomp websocket client.
     * Also performs a cleanup
     */
    disconnect() {
        if (!this.stompConnection)
            return;
        this.stompConnection.forceDisconnect();
        this.stompConnection.deactivate();
        this.stompConnection = undefined;
        this.stompConnectionId = undefined;
        this.client.debug('[STOMP EOS Connect] Disconnected');
    }
    /**
     * Sets up the subscription for the deployment
     * @param connectionResolve connect promise resolve
     * @param connectionReject connect promise reject
     */
    setupSubscription(connectionResolve, connectionReject) {
        this.stompConnection.subscribe(`${this.client.config.eosDeploymentId}/account/${this.client.user.self.id}`, async (message) => {
            var _a, _b, _c;
            if (!((_a = message.headers['content-type']) === null || _a === void 0 ? void 0 : _a.includes('application/json'))) {
                return;
            }
            const messageData = JSON.parse(message.body);
            (_c = (_b = this.client.config).stompEosConnectDebug) === null || _c === void 0 ? void 0 : _c.call(_b, message.body);
            this.client.debug(`new message '${messageData.type}' - ${message.body}`, 'eos-connect');
            switch (messageData.type) {
                case 'core.connect.v1.connected': {
                    this.stompConnectionId = messageData.connectionId;
                    this.client.debug(`[STOMP EOS Connect] Connected as ${messageData.connectionId}`);
                    connectionResolve(messageData.connectionId);
                    break;
                }
                case 'core.connect.v1.connect-failed': {
                    this.client.debug(`failed connecting to eos connect: ${messageData.statusCode} - ${messageData.message}`);
                    connectionReject(new StompConnectionError_1.default(messageData.message, messageData.statusCode));
                    break;
                }
                case 'social.chat.v1.NEW_WHISPER': {
                    const { senderId, body, time } = messageData.payload.message;
                    const friend = this.client.friend.list.get(senderId);
                    if (!friend || senderId === this.client.user.self.id) {
                        return;
                    }
                    const friendMessage = new ReceivedFriendMessage_1.default(this.client, {
                        content: body || '',
                        author: friend,
                        id: messageData.id,
                        sentAt: new Date(time),
                    });
                    this.client.emit('friend:message', friendMessage);
                    break;
                }
                case 'social.chat.v1.NEW_MESSAGE': {
                    if (messageData.payload.conversation.type !== 'party') {
                        return;
                    }
                    await this.client.partyLock.wait();
                    const { conversation: { conversationId }, message: { senderId, body, time } } = messageData.payload;
                    const partyId = conversationId.replace('p-', '');
                    if (!this.client.party
                        || this.client.party.id !== partyId
                        || senderId === this.client.user.self.id) {
                        return;
                    }
                    const authorMember = this.client.party.members.get(senderId);
                    if (!authorMember) {
                        return;
                    }
                    const partyMessage = new PartyMessage_1.default(this.client, {
                        content: body || '',
                        author: authorMember,
                        sentAt: new Date(time),
                        id: messageData.id,
                        party: this.client.party,
                    });
                    this.client.emit('party:member:message', partyMessage);
                    break;
                }
            }
        }, {
            id: 'sub-0',
        });
    }
}
exports.default = EOSConnect;
//# sourceMappingURL=EOSConnect.js.map